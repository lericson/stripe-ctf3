#!/usr/bin/env python
"Maj -- gitcoin miner"

from __future__ import unicode_literals, print_function

import sys
import string
import hashlib
import multiprocessing

winner_commit_queue = multiprocessing.Queue()
hash_rate_queue = multiprocessing.Queue()
reload_condition = multiprocessing.Condition()

author = committer = b'A <b> 1390552808 +0100'
message  = b'Gitcoi\n'
nonce_length = 16
num_processes = 1*multiprocessing.cpu_count()
difficulty = open('difficulty.txt').read().strip()

h = hashlib.sha1()

def commit(tree, parent, author, committer, message):
    return b'\n'.join(
        (b'tree ' + tree,
         b'parent ' + parent,
         b'author ' + author,
         b'committer ' + committer,
         b'',
         message))

def nonce_gen(c, n=16):
    if n != 16:
        0/0
    p = b'Nonce' + c + b' '
    alphabet = string.printable
    for i0 in alphabet:
        for i1 in alphabet:
            for i2 in alphabet:
                for i3 in alphabet:
                    for i4 in alphabet:
                        for i5 in alphabet:
                            for i6 in alphabet:
                                for i7 in alphabet:
                                    yield p+i0+i1+i2+i3+i4+i5+i6+i7+'\n'

def power_on_self_test():
    commit_obj = commit('352ecf915f1dbb28ae13ff6eb72c971f3a96dc78',
                        '000000c47a7ab30b4f6620f7936fb3770ea5506b',
                        'Stripe CTF <ctf@stripe.com> 1390551315 +0000',
                        'Stripe CTF <ctf@stripe.com> 1390551315 +0000',
                        'Mined a Gitcoin!\nnonce 010e1219')
    h = hashlib.sha1('commit %d\0%s' % (len(commit_obj), commit_obj))
    if '00000014c69d468efd589473b90b8049b12d3bda' != h.hexdigest():
        0/0

def update_git():
    # git fetch origin
    # parent = git rev-parse origin/master
    __import__('time').sleep(3.0)

def main(args=sys.argv[1:]):
    power_on_self_test()
    parent, tree = args

    commit_obj = commit(tree, parent, author, committer, message)

    # pad
    #minlen = len(commit_obj)
    #commit_obj += b'HAX ' * 32
    #commit_obj  = commit_obj[:((minlen // h.block_size) + 1) * h.block_size]
    #commit_obj  = commit_obj[:-2] + '\n\n'
    #if (len(commit_obj) % h.block_size) != 0:
    #    0/0

    ps = []
    for i in xrange(num_processes):
        p = multiprocessing.Process(target=worker, args=(i, commit_obj))
        p.start()
        ps.append(p)
    while True:
        while not hash_rate_queue.empty():
            (i, n, t) = hash_rate_queue.get()
            print('Rate worker', i, 'is', n/1e3/t, 'kH/s', file=sys.stderr)
        if not winner_commit_queue.empty():
            winner = winner_commit_queue.get()
            print(winner, end="")
            for p in ps:
                p.terminate()
            break
        update_git()

def worker(i, commit_obj):
    next_nonce = nonce_gen(str(i), nonce_length).next
    if len(next_nonce()) != nonce_length:
        0/0

    print('Starting worker', i, file=sys.stderr)
    h.update(b'commit %d\0%s' % (len(commit_obj) + nonce_length, commit_obj))
    #print('Length:', len(b'commit %d\0%s' % (len(commit_obj) + nonce_length, commit_obj + next_nonce())))
    copy_h = h.copy
    update = type(h).update
    hexdigest = type(h).hexdigest
    commit_id = '\xff'
    import time
    t0 = time.time()
    n = 0
    #n_calc = 0xfffff
    while commit_id >= difficulty:
        h_ = copy_h()
        nonce = next_nonce()
        update(h_, nonce)
        commit_id = hexdigest(h_)
        #n += 1
        #if (n & n_calc) == n_calc:
        if commit_id < difficulty:
            t = time.time() - t0
            hash_rate_queue.put((i, n, t))
            winner_commit_queue.put(commit_obj + nonce)

if __name__ == "__main__":
    main()
