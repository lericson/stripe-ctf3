#!/usr/bin/env node

"use strict";

var http = require('http');
var httpProxy = require('./network_simulation/lib/proxy');
var checkServer = require('./network_simulation/lib/check_server');
var nopt = require('nopt');
var url = require('url');

/* Token bucket filtering */

var nReqs = 0;
var tokenBucketConfig = {rate: null, max: 10};
var tokenBucket = {};
var outstanding = 0;
var proxyRate = 0;

var RequestData = function (request, response, buffer) {
  this.request = request;
  this.response = response;
  this.buffer = buffer;
};

function ipFromRequest(reqData) {
  return reqData.request.headers['x-forwarded-for'];
}

function rejectRequest(reqData) {
  reqData.response.writeHead(400);
  reqData.response.end();
}

var Queue = function (proxies, parameters) {
  this.proxies = proxies;
  this.parameters = parameters;
};
Queue.prototype.takeRequest = function (reqData) {
  var src = ipFromRequest(reqData);
  var bucket = tokenBucket[src];
  var tCurr = new Date();

  if (bucket === undefined) {
    bucket = tokenBucket[src] = {};
    bucket.tPrev = bucket.tStart = tCurr;
    bucket.nTokens = tokenBucketConfig.max;
    bucket.nReqs = 0;
    bucket.outstanding = 0;
    bucket.nRejected = 0;
  } else {
    var t  = (tCurr - bucket.tPrev) / 1e3;
    bucket.nTokens = Math.min(bucket.nTokens + t*proxyRate*0.8,
                              tokenBucketConfig.max);
    bucket.tPrev = tCurr;
  }

  if (bucket.blacklisted) {
    return;
  }

  bucket.nReqs++;
  bucket.nTokens = Math.max(--bucket.nTokens, 0);

  //console.log('request from', src, proxyRate);

  if (outstanding >= 3) {
    if (bucket.nRejected >= 3) {
      outstanding--;
      bucket.outstanding--;
      //console.log('drop request from asshole', src);
      return;
    }

    if ((bucket.outstanding / outstanding) >= 0.8) {
      outstanding--;
      bucket.outstanding--;
      bucket.nRejected++;
      //console.log('rejected due to concurrency', src);
      rejectRequest(reqData);
      return;
    }

  }

  if (bucket.nTokens <= 0) {
    bucket.nTokens = 0;
    outstanding--;
    bucket.outstanding--;
    bucket.nRejected++;
    //console.log('rejected due to rate', src);
    rejectRequest(reqData);
    return;
  }

  var proxy = this.proxies[(nReqs++) % this.proxies.length];
  reqData.request.bucket = bucket;
  reqData.request.proxied = new Date();
  proxy.proxyRequest(reqData.request, reqData.response, reqData.buffer);
};
Queue.prototype.requestStarted = function (req, res) {
  var bucket = req.bucket;
  outstanding++;
  this.outstanding++;
  bucket.outstanding++;
};
Queue.prototype.requestFinished = function (req, res, response) {
  var bucket = req.bucket;
  delete req.bucket;
  bucket.outstanding--;
  this.outstanding--;
  outstanding--;
  var instantRate = 1/(((new Date()) - req.proxied)/1e3);
  proxyRate = (proxyRate + instantRate)/2;
};

function checkBackends(targets, path, response) {
  var toCheck = targets.map(function (target) {
    var output = {};
    output['host'] = target['host'];
    output['port'] = target['port'];
    output['path'] = path;
    return output;
  });
  var success = function () {
    response.writeHead(200, {"Content-Type": "application/json"});
    response.end()
  };
  var error = function () {
    response.writeHead(500, {"Content-Type": "application/json"});
    response.end()
  };
  checkServer.checkServers(toCheck, success, error);
}

function main() {
  var opts = {
    "out-ports": String,
    "in-port": String,
  };
  var parsed = nopt(opts),
      inPort = parsed['in-port'] || '3000',
      outPorts = parsed['out-ports'] ? parsed['out-ports'].split(",") : ['3001'],
      targets = [],
      target,
      proxies = [],
      proxy,
      i;

  for (i = 0; i < outPorts.length; i++) {
    target = {'host': 'localhost', 'port': outPorts[i]};
    targets.push(target);
    proxy = new httpProxy.HttpProxy({'target': target});
    proxy.outstanding = 0;
    proxy.identifier = i;
    proxies.push(proxy);
  }

  var queue = new Queue(proxies, {});
  for (i = 0; i < proxies.length; i++) {
    proxy = proxies[i];
    proxy.on("start", queue.requestStarted);
    proxy.on("end", queue.requestFinished);
  }

  var server = http.createServer(function (req, res) {
    if (req.method === "HEAD") {
      // HEAD requests are used to monitor the status of the simulation
      // proxies[0].proxyRequest(reqData.request, reqData.response, reqData.buffer);
      checkBackends(targets, url.parse(req.url)['pathname'], res);
    } else {
      var buffer = httpProxy.buffer(req);
      var reqData = new RequestData(req, res, buffer);
      queue.takeRequest(reqData);
    }
  });

  server.on('close', function () {
    for (i = 0; i < proxies.length; i++) {
      proxies[i].close();
    }
  });
  console.log("The shield is up and listening.");
  server.listen(inPort);
}

main();
